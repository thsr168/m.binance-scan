<!--20251120_v008 = 更改標的與漲跌幅字體變大-->
<!--20251121_v009 = 更改鼠標移動顯示時間-->
<!--20251210_v010 = 新增突破篩選小工具、最近10根K內，有創過最近120根新高的標的-->
<!--20251211_v011 = 新增突破箭頭，更改時區為台灣時區-->


<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>幣安USDT永續合約小工具_v011</title>
  <!-- lightweight-charts -->
  <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background: #050505;
      color: #eee;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
    }

    /* ======================== 首頁 ======================== */
    #home {
      padding: 20px;
      text-align: center;
    }

    .home-title {
      font-size: 50px;
      font-weight: bold;
      margin: 40px 0 30px;
      text-align: center;
    }

    .home-row {
      margin-bottom: 40px;
      font-size: 26px;
      text-align: center;
    }

    .home-row label {
      display: block;
      margin-bottom: 10px;
    }

    select {
      padding: 16px 20px;
      font-size: 20px;
      border-radius: 10px;
      border: 1px solid #666;
      background: #111;
      color: #eee;
      width: 80%;
      max-width: 330px;
    }

    /* 首頁大按鈕（開始） */
    .big-btn {
      padding: 36px 54px;
      font-size: 48px;
      border-radius: 12px;
      background: #1e1e1e;
      border: none;
      color: #eee;
      width: 80%;
      max-width: 330px;
      margin-top: 20px;
      cursor: pointer;
      transition: 0.15s;
    }

    .big-btn:hover {
      background: #333;
    }

    /* ======================== K 線頁 ======================== */
    #chart-page {
      display: none; /* 開始隱藏，按開始後才顯示 */
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(10, 10, 10, 0.95);
      backdrop-filter: blur(6px);
      padding: 10px 16px;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    header button {
      font-size: 14px !important;
      padding: 6px 12px !important;
    }

    /* 一般按鈕樣式 */
    button {
      padding: 10px 16px;
      font-size: 18px;
      border-radius: 6px;
      background: #111;
      border: 1px solid #555;
      color: #eee;
      cursor: pointer;
    }

    button:hover:not(:disabled) {
      background: #222;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    /* K 線圖容器 */
    #charts {
      padding: 12px 12px 80px 12px;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 18px;
    }

    /* K 線卡片靠右（左側留滑動空白） */
    .chart-wrapper {
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px;
      background: #080808;
      width: 90%;
      box-sizing: border-box;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      margin-left: auto;
      margin-right: 0;
    }

    .chart-title {
      font-size: 25px;
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #f5f5f5;
    }

    .chart-sub {
      font-size: 14px;
      color: #888;
    }

    .chart {
      width: 100%;
      height: 300px;
    }

    .chart-pct { margin-left: 6px; font-size: 20px; }
    .chart-pct.up { color: #16c784; }
    .chart-pct.down { color: #ff4d4d; }
    .chart-pct.flat { color: #aaa; }

    /* 下方分頁 */
    #bottom-nav {
      padding: 14px 16px;
      border-top: 1px solid #333;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      background: #050505;
      position: sticky;
      bottom: 0;
      z-index: 5;
    }
  </style>
</head>
<body>

<!-- ======================== 首頁 ======================== -->
<div id="home">
  <div class="home-title">幣安合約小工具_v011</div>

  <div class="home-row">
    <label>選擇模式：</label>
    <select id="home-mode">
      <option value="scan">掃圖（全部 USDT 永續）</option>
      <option value="filter">篩選（突破標的）</option>
    </select>
  </div>

  <div class="home-row">
    <label>選擇時框：</label>
    <select id="home-interval">
      <option value="15m">15 分 K</option>
      <option value="30m">30 分 K</option>
      <option value="1h">1 小時 K</option>
      <option value="2h">2 小時 K</option>
      <option value="4h">4 小時 K</option>
    </select>
  </div>

  <div class="home-row">
    <label>排序方式：</label>
    <select id="home-sort">
      <option value="symbol">依字母</option>
      <option value="pct_desc">依 24h 漲跌幅</option>
    </select>
  </div>

  <button class="big-btn" id="home-start">開始</button>
</div>

<!-- ======================== K 線頁 ======================== -->
<div id="chart-page">
  <header>
    <button onclick="goHome()">⬅ 返回首頁</button>

    <div style="display:flex; gap:8px;">
      <button id="prev-btn" disabled>上一頁</button>
      <button id="next-btn" disabled>下一頁</button>
    </div>

    <span id="page-info" style="font-size:12px;color:#aaa;">第 0 / 0 頁</span>
    <div id="status" style="font-size:12px;color:#aaa;">尚未掃圖</div>
  </header>

  <div id="charts"></div>

  <footer id="bottom-nav">
    <button id="bottom-prev-btn" disabled>上一頁</button>
    <span id="bottom-page-info" style="font-size:12px;color:#aaa;">第 0 / 0 頁</span>
    <button id="bottom-next-btn" disabled>下一頁</button>
  </footer>
</div>

<script>
  /* ===================== 全域變數 ===================== */
  const BASE_URL = "https://fapi.binance.com";
  const PAGE_SIZE = 100;
  const KLINE_LIMIT = 600;

  let rawSymbols = [];          // 所有 USDT 永續
  let allSymbols = [];          // 目前要顯示的（全部 or 篩選後）
  let tickerMap = {};           // symbol -> { pct }

  let currentPage = 0;
  let currentInterval = "15m";
  let sortMode = "symbol";
  let currentMode = "scan";     // scan / filter

  let currentLoadToken = 0;
  let isLoading = false;

  const chartsEl = document.getElementById("charts");
  const statusEl = document.getElementById("status");
  const prevBtn = document.getElementById("prev-btn");
  const nextBtn = document.getElementById("next-btn");
  const pageInfoEl = document.getElementById("page-info");
  const bottomPrevBtn = document.getElementById("bottom-prev-btn");
  const bottomNextBtn = document.getElementById("bottom-next-btn");
  const bottomPageInfoEl = document.getElementById("bottom-page-info");

  const klinesCache = new Map();
  let observer = null;

  /* ===================== 頁面切換 ===================== */
  function goChartPage() {
    document.getElementById("home").style.display = "none";
    document.getElementById("chart-page").style.display = "block";
  }

  function goHome() {
    for (const child of Array.from(chartsEl.children)) {
      unmountChart(child);
      if (observer) observer.unobserve(child);
    }
    chartsEl.innerHTML = "";
    document.getElementById("home").style.display = "block";
    document.getElementById("chart-page").style.display = "none";
    statusEl.textContent = "尚未掃圖";
  }

  /* ===================== 幣安 API ===================== */
  async function fetchFuturesSymbols() {
    const res = await fetch(`${BASE_URL}/fapi/v1/exchangeInfo`);
    const data = await res.json();
    return data.symbols
      .filter(s =>
        s.contractType === "PERPETUAL" &&
        s.quoteAsset === "USDT" &&
        s.status === "TRADING"
      )
      .map(s => s.symbol)
      .sort();
  }

  async function fetch24hTickers(symbols) {
    const res = await fetch(`${BASE_URL}/fapi/v1/ticker/24hr`);
    const data = await res.json();
    const set = new Set(symbols);
    const map = {};
    for (const t of data) {
      if (!set.has(t.symbol)) continue;
      const pct = parseFloat(t.priceChangePercent);
      if (!Number.isNaN(pct)) {
        map[t.symbol] = { pct };
      }
    }
    return map;
  }

  async function fetchKlines(symbol, interval, limit = KLINE_LIMIT) {
    const key = `${symbol}_${interval}`;
    if (klinesCache.has(key)) return klinesCache.get(key);

    const url = `${BASE_URL}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    const res = await fetch(url);
    const raw = await res.json();

    const bars = raw.map(c => ({
      time: c[0] / 1000,
      open: +c[1],
      high: +c[2],
      low: +c[3],
      close: +c[4],
      volume: +c[5],
    }));

    klinesCache.set(key, bars);
    return bars;
  }

  function calcMA(data, period) {
    const out = [];
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      sum += data[i].close;
      if (i >= period) sum -= data[i - period].close;
      if (i >= period - 1) {
        out.push({ time: data[i].time, value: sum / period });
      }
    }
    return out;
  }

  /* ========== 突破條件：最近 10 根內，創最近 120 根新高 ========== */
  function checkBreakoutLast10Of120(data) {
    if (!data || data.length < 120) return false;

    const len = data.length;
    const recent120 = data.slice(len - 120);
    const recent10  = recent120.slice(-10);

    let h120 = -Infinity;
    for (const bar of recent120) {
      if (bar.high > h120) h120 = bar.high;
    }

    let h10 = -Infinity;
    for (const bar of recent10) {
      if (bar.high > h10) h10 = bar.high;
    }

    return h10 === h120;
  }
	/* ============================================================
   ⭐ 找出突破發生在 recent 10 根內的哪一根 K
============================================================ */
function findBreakoutIndex(data) {
  if (!data || data.length < 120) return null;

  const len = data.length;
  const recent120 = data.slice(len - 120);
  const recent10  = recent120.slice(-10);

  let h120 = -Infinity;
  for (const bar of recent120) {
    if (bar.high > h120) h120 = bar.high;
  }

  for (let i = 0; i < recent10.length; i++) {
    if (recent10[i].high === h120) {
      return (len - 10) + i;  
    }
  }

  return null;
}

  async function filterBreakoutSymbols(symbols, interval) {
    const result = [];
    let checked = 0;
    for (const sym of symbols) {
      try {
        const data = await fetchKlines(sym, interval, KLINE_LIMIT);
        if (checkBreakoutLast10Of120(data)) {
          result.push(sym);
        }
      } catch (e) {
        console.error("篩選 K 線失敗：", sym, e);
      }
      checked++;
      statusEl.textContent = `篩選中（${checked} / ${symbols.length}）`;
      await new Promise(r => setTimeout(r));
    }
    return result;
  }

  /* ===================== 卡片 / Lazy Load ===================== */
  function buildCard(symbol, interval, container, changePct) {
    const wrap = document.createElement("div");
    wrap.className = "chart-wrapper";

    const title = document.createElement("div");
    title.className = "chart-title";

    const left = document.createElement("span");
    left.textContent = symbol;

    if (typeof changePct === "number") {
      const pctSpan = document.createElement("span");
      pctSpan.className = "chart-pct";
      if (changePct > 0) pctSpan.classList.add("up");
      else if (changePct < 0) pctSpan.classList.add("down");
      else pctSpan.classList.add("flat");
      pctSpan.textContent =
        (changePct >= 0 ? "+" : "") + changePct.toFixed(2) + "%";
      left.appendChild(pctSpan);
    }

    const right = document.createElement("span");
    right.className = "chart-sub";
    right.textContent = interval;

    title.appendChild(left);
    title.appendChild(right);

    const chartDiv = document.createElement("div");
    chartDiv.className = "chart";

    wrap.appendChild(title);
    wrap.appendChild(chartDiv);
    container.appendChild(wrap);

    wrap._symbol = symbol;
    wrap._interval = interval;
    wrap._pct = changePct;
    wrap._chartDiv = chartDiv;
    wrap._chartInstance = null;
    wrap._loading = false;

    if (observer) observer.observe(wrap);
    return wrap;
  }

  async function mountChart(card) {
    if (card._chartInstance || card._loading) return;
    card._loading = true;

    try {
      const symbol = card._symbol;
      const interval = card._interval;
      const data = await fetchKlines(symbol, interval, KLINE_LIMIT);

      if (!card.isConnected) return;

      const chart = LightweightCharts.createChart(card._chartDiv, {
        width: card._chartDiv.clientWidth,
        height: 300,
        layout: {
          background: { color: "#080808" },
          textColor: "#ddd",
        },
        grid: {
          vertLines: { color: "#222" },
          horzLines: { color: "#222" },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
          tickMarkFormatter: (time) => {
  const date = new Date(time * 1000);
  const tw = new Date(date.getTime());
  const h = tw.getHours().toString().padStart(2, "0");
  const m = tw.getMinutes().toString().padStart(2, "0");
  return `${h}:${m}`;
},
},

        rightPriceScale: { visible: true },
      });

      chart.applyOptions({
  localization: {
    timeFormatter: (time) => {
      const date = new Date(time * 1000);
      const tw = new Date(date.getTime());
      const yyyy = tw.getFullYear();
      const mm = (tw.getMonth() + 1).toString().padStart(2, "0");
      const dd = tw.getDate().toString().padStart(2, "0");
      const hh = tw.getHours().toString().padStart(2, "0");
      const mi = tw.getMinutes().toString().padStart(2, "0");
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }
  }
});


      const candleSeries = chart.addCandlestickSeries({
        upColor: "#f7525f",
        borderUpColor: "#f7525f",
        wickUpColor: "#f7525f",
        downColor: "#22ab94",
        borderDownColor: "#22ab94",
        wickDownColor: "#22ab94",
      });
      candleSeries.setData(data);
/* ============================================================
   ⭐ 新增突破箭頭（只在篩選模式顯示）
============================================================ */
if (currentMode === "filter") {
  const breakoutIndex = findBreakoutIndex(data);

  if (breakoutIndex !== null) {
    const bar = data[breakoutIndex];

    const marker = {
      time: bar.time,
      position: "aboveBar",
      color: "yellow",
      shape: "arrowDown",
      text: "最高點",
    };

    candleSeries.setMarkers([marker]);
  }
}


      const volSeries = chart.addHistogramSeries({
        priceScaleId: "volume",
        priceFormat: { type: "volume" },
        priceLineVisible: false,
        lastValueVisible: false,
      });
      volSeries.setData(
        data.map(d => ({
          time: d.time,
          value: d.volume,
          color: d.close >= d.open ? "#f7525f" : "#22ab94",
        }))
      );
      chart.priceScale("volume").applyOptions({
        scaleMargins: { top: 0.8, bottom: 0 },
      });

      const ma30 = calcMA(data, 30);
      const ma45 = calcMA(data, 45);
      const ma60 = calcMA(data, 60);

      chart.addLineSeries({
        color: "#f77c80",
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      }).setData(ma30);

      chart.addLineSeries({
        color: "#ffb74d",
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      }).setData(ma45);

      chart.addLineSeries({
        color: "#66bb6a",
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      }).setData(ma60);

      const totalBars = data.length;
      if (totalBars > 0) {
        const visibleBars = 120;
        const blankBars = 10;
        const from = Math.max(0, totalBars - visibleBars);
        const to = totalBars + blankBars;
        chart.timeScale().applyOptions({ rightOffset: blankBars });
        chart.timeScale().setVisibleLogicalRange({ from, to });
      }

      card._chartInstance = chart;
    } catch (err) {
      console.error("繪製圖表錯誤：", err);
    } finally {
      card._loading = false;
    }
  }

  function unmountChart(card) {
    if (card._chartInstance) {
      card._chartInstance.remove();
      card._chartInstance = null;
    }
    if (card._chartDiv) {
      card._chartDiv.innerHTML = "";
    }
  }

  /* ===================== 分頁 / 排序 ===================== */
  function applySorting() {
    if (!allSymbols || allSymbols.length === 0) return;
    if (sortMode === "symbol") {
      allSymbols.sort();
    } else if (sortMode === "pct_desc") {
      allSymbols.sort((a, b) => {
        const pa = tickerMap[a]?.pct ?? -Infinity;
        const pb = tickerMap[b]?.pct ?? -Infinity;
        return pb - pa;
      });
    }
  }

  function updatePaginationUI() {
    const total = allSymbols.length;
    const totalPages = total ? Math.ceil(total / PAGE_SIZE) : 0;

    if (!totalPages) {
      pageInfoEl.textContent = "第 0 / 0 頁";
      bottomPageInfoEl.textContent = "第 0 / 0 頁";
      prevBtn.disabled = nextBtn.disabled = true;
      bottomPrevBtn.disabled = bottomNextBtn.disabled = true;
      return;
    }

    const start = currentPage * PAGE_SIZE + 1;
    const end = Math.min((currentPage + 1) * PAGE_SIZE, total);
    const text = `第 ${currentPage + 1} / ${totalPages} 頁（${start}–${end} / ${total} 檔）`;

    pageInfoEl.textContent = text;
    bottomPageInfoEl.textContent = text;

    const disablePrev = currentPage <= 0;
    const disableNext = currentPage >= totalPages - 1;
    prevBtn.disabled = disablePrev;
    nextBtn.disabled = disableNext;
    bottomPrevBtn.disabled = disablePrev;
    bottomNextBtn.disabled = disableNext;
  }

  async function loadPage(pageIndex) {
    const totalPages = Math.ceil(allSymbols.length / PAGE_SIZE);
    if (pageIndex < 0 || pageIndex >= totalPages) return;

    window.scrollTo({ top: 0, behavior: "smooth" });

    const token = ++currentLoadToken;
    currentPage = pageIndex;
    updatePaginationUI();

    for (const child of Array.from(chartsEl.children)) {
      if (observer) observer.unobserve(child);
      unmountChart(child);
    }
    chartsEl.innerHTML = "";

    const start = pageIndex * PAGE_SIZE;
    const end = Math.min(start + PAGE_SIZE, allSymbols.length);
    const targets = allSymbols.slice(start, end);

    for (const sym of targets) {
      if (token !== currentLoadToken) return;
      const pct = tickerMap[sym]?.pct ?? null;
      buildCard(sym, currentInterval, chartsEl, pct);
    }
  }

  /* ===================== 主流程：掃圖 / 篩選 ===================== */
  async function scan() {
    if (isLoading) return;
    isLoading = true;

    currentMode = document.getElementById("home-mode").value;
    currentInterval = document.getElementById("home-interval").value;
    sortMode = document.getElementById("home-sort").value;

    goChartPage();
    statusEl.textContent = "取得合約列表中…";
    currentLoadToken++;

    try {
      if (rawSymbols.length === 0) {
        rawSymbols = await fetchFuturesSymbols();
      }

      if (rawSymbols.length === 0) {
        statusEl.textContent = "沒有取得到任何 USDT 永續合約 symbol。";
        isLoading = false;
        updatePaginationUI();
        return;
      }

      statusEl.textContent = "取得 24h 漲跌幅中…";
      tickerMap = await fetch24hTickers(rawSymbols);

      if (currentMode === "filter") {
        statusEl.textContent = `依 ${currentInterval} 篩選突破中…`;
        const breakoutSymbols = await filterBreakoutSymbols(rawSymbols, currentInterval);
        allSymbols = breakoutSymbols;

        if (allSymbols.length === 0) {
          statusEl.textContent = `沒有符合「最近 10 根內創最近 120 根新高」條件的標的（${currentInterval}）。`;
          isLoading = false;
          chartsEl.innerHTML = "";
          updatePaginationUI();
          return;
        }
      } else {
        allSymbols = rawSymbols.slice();
      }

      applySorting();
      updatePaginationUI();

      if (currentMode === "filter") {
        statusEl.textContent = `共 ${allSymbols.length} 檔符合突破條件，準備載入第 1 頁…`;
      } else {
        statusEl.textContent = `共 ${allSymbols.length} 檔 USDT 永續合約，準備載入第 1 頁…`;
      }

      isLoading = false;
      await loadPage(0);
    } catch (err) {
      console.error("掃圖發生錯誤:", err);
      statusEl.textContent = "發生錯誤，請打開 F12 → Console 看錯誤訊息。";
      isLoading = false;
      updatePaginationUI();
    }
  }

  /* ===================== IntersectionObserver ===================== */
  if ("IntersectionObserver" in window) {
    observer = new IntersectionObserver(
      entries => {
        for (const entry of entries) {
          const card = entry.target;
          if (entry.isIntersecting) {
            mountChart(card);
          } else {
            unmountChart(card);
          }
        }
      },
      { root: null, threshold: 0.1 }
    );
  } else {
    console.warn("此瀏覽器不支援 IntersectionObserver，Lazy Load 失效。");
  }

  /* ===================== 事件綁定 ===================== */
  document.getElementById("home-start").addEventListener("click", scan);
  prevBtn.addEventListener("click", () => loadPage(currentPage - 1));
  nextBtn.addEventListener("click", () => loadPage(currentPage + 1));
  bottomPrevBtn.addEventListener("click", () => loadPage(currentPage - 1));
  bottomNextBtn.addEventListener("click", () => loadPage(currentPage + 1));

  window.addEventListener("resize", () => {
    const cards = document.querySelectorAll(".chart-wrapper");
    cards.forEach(card => {
      if (card._chartInstance && card._chartDiv) {
        card._chartInstance.applyOptions({
          width: card._chartDiv.clientWidth,
        });
      }
    });
  });

  updatePaginationUI();
</script>
</body>
</html>
